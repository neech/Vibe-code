<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Japanese Koi Pond - 3D Experience</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #0a1a0a;
            font-family: 'Noto Serif JP', 'Georgia', serif;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
        }

        canvas {
            display: block;
        }

        /* Overlay UI */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        .title-card {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: #f5f0e6;
            text-shadow: 0 2px 20px rgba(0, 0, 0, 0.8);
        }

        .title-card h1 {
            font-size: 2.5rem;
            font-weight: 300;
            letter-spacing: 0.3em;
            margin-bottom: 8px;
            background: linear-gradient(135deg, #f5f0e6 0%, #d4af37 50%, #f5f0e6 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .title-card p {
            font-size: 0.9rem;
            opacity: 0.7;
            letter-spacing: 0.2em;
        }

        .controls-hint {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: #f5f0e6;
            font-size: 0.8rem;
            opacity: 0.5;
            letter-spacing: 0.1em;
            text-shadow: 0 1px 10px rgba(0, 0, 0, 0.8);
        }

        .time-display {
            position: absolute;
            top: 30px;
            right: 30px;
            color: #f5f0e6;
            font-size: 1rem;
            opacity: 0.6;
            text-shadow: 0 1px 10px rgba(0, 0, 0, 0.8);
        }

        /* Decorative corners */
        .corner {
            position: absolute;
            width: 60px;
            height: 60px;
            border: 1px solid rgba(212, 175, 55, 0.3);
        }

        .corner-tl { top: 20px; left: 20px; border-right: none; border-bottom: none; }
        .corner-tr { top: 20px; right: 20px; border-left: none; border-bottom: none; }
        .corner-bl { bottom: 20px; left: 20px; border-right: none; border-top: none; }
        .corner-br { bottom: 20px; right: 20px; border-left: none; border-top: none; }

        /* Loading screen */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a1a0a 0%, #1a2f1a 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 1s ease-out;
        }

        #loading.fade-out {
            opacity: 0;
            pointer-events: none;
        }

        .loading-text {
            color: #d4af37;
            font-size: 1.2rem;
            letter-spacing: 0.5em;
            margin-bottom: 30px;
        }

        .loading-bar {
            width: 200px;
            height: 2px;
            background: rgba(212, 175, 55, 0.2);
            border-radius: 1px;
            overflow: hidden;
        }

        .loading-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #d4af37, #f5f0e6);
            width: 0%;
            animation: loading 2s ease-in-out forwards;
        }

        @keyframes loading {
            0% { width: 0%; }
            100% { width: 100%; }
        }

        /* Fish counter */
        .fish-counter {
            position: absolute;
            bottom: 30px;
            right: 30px;
            color: #f5f0e6;
            font-size: 0.9rem;
            opacity: 0.6;
            text-shadow: 0 1px 10px rgba(0, 0, 0, 0.8);
        }

        .fish-counter span {
            color: #d4af37;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading">
        <div class="loading-text">静寂の池</div>
        <div class="loading-bar">
            <div class="loading-bar-fill"></div>
        </div>
    </div>

    <!-- 3D Canvas Container -->
    <div id="canvas-container"></div>

    <!-- Overlay UI -->
    <div class="overlay">
        <div class="corner corner-tl"></div>
        <div class="corner corner-tr"></div>
        <div class="corner corner-bl"></div>
        <div class="corner corner-br"></div>

        <div class="title-card">
            <h1>鯉の池</h1>
            <p>Koi Pond</p>
        </div>

        <div class="time-display" id="time-display"></div>

        <div class="fish-counter">
            Koi: <span id="fish-count">9</span>
        </div>

        <div class="controls-hint">
            Drag to rotate • Scroll to zoom • Double-click to focus
        </div>
    </div>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // ============================================
        // CONFIGURATION
        // ============================================
        const CONFIG = {
            pond: {
                radius: 12,
                depth: 2.5,
                segments: 64
            },
            water: {
                color: 0x1a4a3a,
                opacity: 0.85,
                waveSpeed: 0.5,
                waveAmplitude: 0.08
            },
            fish: {
                count: 9,
                colors: [
                    { body: 0xff4500, accent: 0xffffff },  // Red-white
                    { body: 0xffa500, accent: 0xffffff },  // Orange-white
                    { body: 0xffd700, accent: 0xff4500 },  // Gold-red
                    { body: 0xffffff, accent: 0xff4500 },  // White-red
                    { body: 0x1a1a1a, accent: 0xff4500 },  // Black-red
                    { body: 0xff6347, accent: 0xffd700 },  // Coral-gold
                    { body: 0xffffff, accent: 0xffa500 },  // White-orange
                    { body: 0xff8c00, accent: 0x1a1a1a },  // Dark orange-black
                    { body: 0xfffacd, accent: 0xff4500 }   // Cream-red
                ],
                minSize: 0.3,
                maxSize: 0.6,
                swimSpeed: 0.3
            },
            lighting: {
                ambient: 0x404040,
                directional: 0xfff5e6,
                intensity: 1.2
            }
        };

        // ============================================
        // GLOBAL VARIABLES
        // ============================================
        let scene, camera, renderer, controls;
        let water, waterMaterial;
        let fishes = [];
        let clock = new THREE.Clock();
        let mousePos = new THREE.Vector2();

        // ============================================
        // INITIALIZATION
        // ============================================
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a1a0a);
            scene.fog = new THREE.Fog(0x0a1a0a, 15, 40);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(8, 10, 12);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.1;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 5;
            controls.maxDistance = 25;
            controls.maxPolarAngle = Math.PI / 2.2;
            controls.target.set(0, -0.5, 0);

            // Build scene
            createLighting();
            createEnvironment();
            createPond();
            createWater();
            createRocks();
            createPlants();
            createKoiFish();
            createLilyPads();
            createLantern();

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousemove', onMouseMove);
            renderer.domElement.addEventListener('dblclick', onDoubleClick);

            // Update time display
            updateTimeDisplay();
            setInterval(updateTimeDisplay, 1000);

            // Hide loading screen
            setTimeout(() => {
                document.getElementById('loading').classList.add('fade-out');
            }, 2500);

            // Start animation
            animate();
        }

        // ============================================
        // LIGHTING
        // ============================================
        function createLighting() {
            // Ambient light
            const ambient = new THREE.AmbientLight(CONFIG.lighting.ambient, 0.6);
            scene.add(ambient);

            // Main directional light (sun)
            const sunLight = new THREE.DirectionalLight(CONFIG.lighting.directional, CONFIG.lighting.intensity);
            sunLight.position.set(10, 20, 10);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 2048;
            sunLight.shadow.mapSize.height = 2048;
            sunLight.shadow.camera.near = 0.5;
            sunLight.shadow.camera.far = 50;
            sunLight.shadow.camera.left = -20;
            sunLight.shadow.camera.right = 20;
            sunLight.shadow.camera.top = 20;
            sunLight.shadow.camera.bottom = -20;
            sunLight.shadow.bias = -0.0001;
            scene.add(sunLight);

            // Soft fill light
            const fillLight = new THREE.DirectionalLight(0x87ceeb, 0.3);
            fillLight.position.set(-5, 10, -5);
            scene.add(fillLight);

            // Warm rim light
            const rimLight = new THREE.DirectionalLight(0xffd700, 0.2);
            rimLight.position.set(-10, 5, 10);
            scene.add(rimLight);
        }

        // ============================================
        // ENVIRONMENT
        // ============================================
        function createEnvironment() {
            // Ground plane
            const groundGeom = new THREE.PlaneGeometry(100, 100);
            const groundMat = new THREE.MeshStandardMaterial({
                color: 0x2d4a2d,
                roughness: 0.9,
                metalness: 0.1
            });
            const ground = new THREE.Mesh(groundGeom, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -2.6;
            ground.receiveShadow = true;
            scene.add(ground);

            // Sky dome
            const skyGeom = new THREE.SphereGeometry(50, 32, 32);
            const skyMat = new THREE.MeshBasicMaterial({
                color: 0x1a2f3a,
                side: THREE.BackSide
            });
            const sky = new THREE.Mesh(skyGeom, skyMat);
            scene.add(sky);
        }

        // ============================================
        // POND
        // ============================================
        function createPond() {
            // Pond basin (organic shape)
            const pondShape = new THREE.Shape();
            const numPoints = 24;
            
            for (let i = 0; i <= numPoints; i++) {
                const angle = (i / numPoints) * Math.PI * 2;
                const radius = CONFIG.pond.radius + Math.sin(angle * 3) * 1.5 + Math.cos(angle * 5) * 0.8;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                
                if (i === 0) {
                    pondShape.moveTo(x, y);
                } else {
                    pondShape.lineTo(x, y);
                }
            }

            // Pond edge (stone border)
            const edgeGeom = new THREE.ExtrudeGeometry(pondShape, {
                depth: 0.4,
                bevelEnabled: true,
                bevelThickness: 0.2,
                bevelSize: 0.3,
                bevelSegments: 3
            });

            const stoneMat = new THREE.MeshStandardMaterial({
                color: 0x4a4a4a,
                roughness: 0.85,
                metalness: 0.1
            });

            const edge = new THREE.Mesh(edgeGeom, stoneMat);
            edge.rotation.x = -Math.PI / 2;
            edge.position.y = -0.3;
            edge.castShadow = true;
            edge.receiveShadow = true;
            scene.add(edge);

            // Inner pond bottom
            const innerShape = new THREE.Shape();
            for (let i = 0; i <= numPoints; i++) {
                const angle = (i / numPoints) * Math.PI * 2;
                const radius = (CONFIG.pond.radius - 0.5) + Math.sin(angle * 3) * 1.3 + Math.cos(angle * 5) * 0.6;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                
                if (i === 0) {
                    innerShape.moveTo(x, y);
                } else {
                    innerShape.lineTo(x, y);
                }
            }

            const bottomGeom = new THREE.ShapeGeometry(innerShape);
            const bottomMat = new THREE.MeshStandardMaterial({
                color: 0x1a3020,
                roughness: 1,
                metalness: 0
            });

            const bottom = new THREE.Mesh(bottomGeom, bottomMat);
            bottom.rotation.x = -Math.PI / 2;
            bottom.position.y = -CONFIG.pond.depth;
            bottom.receiveShadow = true;
            scene.add(bottom);
        }

        // ============================================
        // WATER
        // ============================================
        function createWater() {
            const waterGeom = new THREE.CircleGeometry(CONFIG.pond.radius + 1, CONFIG.pond.segments);

            waterMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uWaterColor: { value: new THREE.Color(CONFIG.water.color) },
                    uDeepColor: { value: new THREE.Color(0x0a2018) },
                    uOpacity: { value: CONFIG.water.opacity },
                    uWaveAmplitude: { value: CONFIG.water.waveAmplitude },
                    uMouse: { value: new THREE.Vector2(0.5, 0.5) }
                },
                vertexShader: `
                    uniform float uTime;
                    uniform float uWaveAmplitude;
                    varying vec2 vUv;
                    varying float vElevation;

                    void main() {
                        vUv = uv;
                        vec3 pos = position;
                        
                        // Complex wave pattern
                        float wave1 = sin(pos.x * 0.5 + uTime * 0.8) * cos(pos.y * 0.3 + uTime * 0.6);
                        float wave2 = sin(pos.x * 0.8 - uTime * 0.5) * sin(pos.y * 0.6 + uTime * 0.7);
                        float wave3 = cos(pos.x * 0.3 + pos.y * 0.4 + uTime * 0.4);
                        
                        vElevation = (wave1 + wave2 + wave3) * uWaveAmplitude;
                        pos.z += vElevation;
                        
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 uWaterColor;
                    uniform vec3 uDeepColor;
                    uniform float uOpacity;
                    uniform float uTime;
                    uniform vec2 uMouse;
                    varying vec2 vUv;
                    varying float vElevation;

                    void main() {
                        // Distance from center for depth effect
                        float distFromCenter = length(vUv - 0.5) * 2.0;
                        
                        // Mix colors based on position and waves
                        vec3 color = mix(uWaterColor, uDeepColor, distFromCenter * 0.5);
                        
                        // Add shimmer based on wave elevation
                        float shimmer = (vElevation + 0.1) * 2.0;
                        color += vec3(0.1, 0.15, 0.1) * shimmer;
                        
                        // Subtle caustics effect
                        float caustic = sin(vUv.x * 20.0 + uTime) * sin(vUv.y * 20.0 + uTime * 0.7) * 0.03;
                        color += vec3(caustic);
                        
                        // Fresnel-like edge brightening
                        float edge = 1.0 - distFromCenter;
                        color += vec3(0.05, 0.08, 0.05) * edge * edge;
                        
                        gl_FragColor = vec4(color, uOpacity);
                    }
                `,
                transparent: true,
                side: THREE.DoubleSide
            });

            water = new THREE.Mesh(waterGeom, waterMaterial);
            water.rotation.x = -Math.PI / 2;
            water.position.y = -0.1;
            scene.add(water);
        }

        // ============================================
        // ROCKS
        // ============================================
        function createRocks() {
            const rockPositions = [
                { x: -8, z: 8, scale: 1.8, rotation: 0.3 },
                { x: -10, z: 5, scale: 1.2, rotation: 1.2 },
                { x: -7, z: 10, scale: 0.8, rotation: 2.1 },
                { x: 9, z: -6, scale: 1.5, rotation: 0.8 },
                { x: 11, z: -4, scale: 1.0, rotation: 1.5 },
                { x: 8, z: -8, scale: 0.7, rotation: 2.8 },
                { x: -5, z: -9, scale: 1.3, rotation: 0.5 },
                { x: 6, z: 9, scale: 1.1, rotation: 1.8 },
                { x: 0, z: 11, scale: 0.9, rotation: 2.4 }
            ];

            rockPositions.forEach(pos => {
                const rock = createRock(pos.scale);
                rock.position.set(pos.x, -0.5, pos.z);
                rock.rotation.y = pos.rotation;
                scene.add(rock);
            });

            // Feature rock in pond
            const featureRock = createRock(1.4);
            featureRock.position.set(4, -0.3, 2);
            scene.add(featureRock);
        }

        function createRock(scale) {
            const geometry = new THREE.DodecahedronGeometry(scale, 1);
            
            // Deform vertices for natural look
            const positions = geometry.attributes.position;
            for (let i = 0; i < positions.count; i++) {
                const x = positions.getX(i);
                const y = positions.getY(i);
                const z = positions.getZ(i);
                
                const noise = Math.random() * 0.3 - 0.15;
                positions.setX(i, x * (1 + noise));
                positions.setY(i, y * (0.6 + noise * 0.5));
                positions.setZ(i, z * (1 + noise));
            }
            
            geometry.computeVertexNormals();

            const material = new THREE.MeshStandardMaterial({
                color: 0x3a3a3a,
                roughness: 0.9,
                metalness: 0.05,
                flatShading: true
            });

            const rock = new THREE.Mesh(geometry, material);
            rock.castShadow = true;
            rock.receiveShadow = true;
            
            return rock;
        }

        // ============================================
        // PLANTS
        // ============================================
        function createPlants() {
            // Bamboo cluster
            createBambooCluster(-10, 8, 5);
            createBambooCluster(9, -7, 4);

            // Ornamental grasses
            createGrassCluster(-6, -10, 8);
            createGrassCluster(7, 8, 6);
            createGrassCluster(-9, 2, 5);

            // Ferns near water edge
            createFerns();
        }

        function createBambooCluster(x, z, count) {
            const group = new THREE.Group();

            for (let i = 0; i < count; i++) {
                const height = 3 + Math.random() * 4;
                const bamboo = createBambooStalk(height);
                bamboo.position.set(
                    (Math.random() - 0.5) * 2,
                    0,
                    (Math.random() - 0.5) * 2
                );
                group.add(bamboo);
            }

            group.position.set(x, -0.5, z);
            scene.add(group);
        }

        function createBambooStalk(height) {
            const group = new THREE.Group();
            const segments = Math.floor(height / 0.8);

            for (let i = 0; i < segments; i++) {
                const segHeight = height / segments;
                const radius = 0.08 - i * 0.003;

                const geometry = new THREE.CylinderGeometry(radius, radius + 0.01, segHeight, 8);
                const material = new THREE.MeshStandardMaterial({
                    color: 0x4a6b35,
                    roughness: 0.7,
                    metalness: 0.1
                });

                const segment = new THREE.Mesh(geometry, material);
                segment.position.y = i * segHeight + segHeight / 2;
                segment.castShadow = true;
                group.add(segment);

                // Node ring
                if (i > 0) {
                    const nodeGeom = new THREE.TorusGeometry(radius + 0.02, 0.015, 8, 16);
                    const nodeMat = new THREE.MeshStandardMaterial({ color: 0x3a5a28 });
                    const node = new THREE.Mesh(nodeGeom, nodeMat);
                    node.position.y = i * segHeight;
                    node.rotation.x = Math.PI / 2;
                    group.add(node);
                }
            }

            // Leaves at top
            for (let i = 0; i < 6; i++) {
                const leafGeom = new THREE.PlaneGeometry(0.4, 0.08);
                const leafMat = new THREE.MeshStandardMaterial({
                    color: 0x5a8040,
                    side: THREE.DoubleSide
                });
                const leaf = new THREE.Mesh(leafGeom, leafMat);
                leaf.position.y = height - 0.3;
                leaf.rotation.y = (i / 6) * Math.PI * 2;
                leaf.rotation.z = Math.PI / 4;
                group.add(leaf);
            }

            return group;
        }

        function createGrassCluster(x, z, count) {
            const group = new THREE.Group();

            for (let i = 0; i < count; i++) {
                const blade = createGrassBlade();
                blade.position.set(
                    (Math.random() - 0.5) * 1.5,
                    0,
                    (Math.random() - 0.5) * 1.5
                );
                blade.rotation.y = Math.random() * Math.PI * 2;
                group.add(blade);
            }

            group.position.set(x, -0.5, z);
            scene.add(group);
        }

        function createGrassBlade() {
            const curve = new THREE.QuadraticBezierCurve3(
                new THREE.Vector3(0, 0, 0),
                new THREE.Vector3(0.1, 0.8, 0),
                new THREE.Vector3(0.3, 1.2, 0)
            );

            const geometry = new THREE.TubeGeometry(curve, 8, 0.02, 4, false);
            const material = new THREE.MeshStandardMaterial({
                color: 0x5a7a45,
                roughness: 0.8
            });

            return new THREE.Mesh(geometry, material);
        }

        function createFerns() {
            const positions = [
                { x: -8, z: 3 },
                { x: 5, z: -8 },
                { x: -3, z: 9 },
                { x: 8, z: 4 }
            ];

            positions.forEach(pos => {
                const fern = createFern();
                fern.position.set(pos.x, -0.4, pos.z);
                scene.add(fern);
            });
        }

        function createFern() {
            const group = new THREE.Group();
            const frondCount = 8;

            for (let i = 0; i < frondCount; i++) {
                const angle = (i / frondCount) * Math.PI * 2;
                const frond = createFrond();
                frond.rotation.y = angle;
                frond.rotation.z = Math.PI / 6;
                group.add(frond);
            }

            return group;
        }

        function createFrond() {
            const curve = new THREE.QuadraticBezierCurve3(
                new THREE.Vector3(0, 0.1, 0),
                new THREE.Vector3(0.3, 0.4, 0),
                new THREE.Vector3(0.6, 0.2, 0)
            );

            const geometry = new THREE.TubeGeometry(curve, 8, 0.03, 4, false);
            const material = new THREE.MeshStandardMaterial({
                color: 0x3a6030,
                roughness: 0.8,
                side: THREE.DoubleSide
            });

            const frond = new THREE.Mesh(geometry, material);
            frond.castShadow = true;
            return frond;
        }

        // ============================================
        // KOI FISH
        // ============================================
        function createKoiFish() {
            for (let i = 0; i < CONFIG.fish.count; i++) {
                const fish = createSingleKoi(i);
                fishes.push(fish);
                scene.add(fish.group);
            }
        }

        function createSingleKoi(index) {
            const group = new THREE.Group();
            const colorScheme = CONFIG.fish.colors[index % CONFIG.fish.colors.length];
            const size = CONFIG.fish.minSize + Math.random() * (CONFIG.fish.maxSize - CONFIG.fish.minSize);

            // Body
            const bodyGeom = new THREE.SphereGeometry(size, 16, 12);
            bodyGeom.scale(2.2, 0.6, 0.8);

            const bodyMat = new THREE.MeshStandardMaterial({
                color: colorScheme.body,
                roughness: 0.3,
                metalness: 0.4
            });

            const body = new THREE.Mesh(bodyGeom, bodyMat);
            group.add(body);

            // Pattern spots
            const spotCount = 3 + Math.floor(Math.random() * 4);
            for (let i = 0; i < spotCount; i++) {
                const spotGeom = new THREE.SphereGeometry(size * 0.25, 8, 8);
                const spotMat = new THREE.MeshStandardMaterial({
                    color: colorScheme.accent,
                    roughness: 0.3,
                    metalness: 0.4
                });
                const spot = new THREE.Mesh(spotGeom, spotMat);
                spot.position.set(
                    (Math.random() - 0.5) * size * 2,
                    size * 0.2,
                    (Math.random() - 0.5) * size * 0.5
                );
                spot.scale.set(1.5, 0.8, 1);
                group.add(spot);
            }

            // Head
            const headGeom = new THREE.SphereGeometry(size * 0.5, 12, 10);
            headGeom.scale(1, 0.7, 0.9);
            const head = new THREE.Mesh(headGeom, bodyMat);
            head.position.x = size * 1.5;
            group.add(head);

            // Eyes
            const eyeGeom = new THREE.SphereGeometry(size * 0.08, 8, 8);
            const eyeMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, metalness: 0.8 });
            
            const leftEye = new THREE.Mesh(eyeGeom, eyeMat);
            leftEye.position.set(size * 1.7, size * 0.15, size * 0.25);
            group.add(leftEye);

            const rightEye = new THREE.Mesh(eyeGeom, eyeMat);
            rightEye.position.set(size * 1.7, size * 0.15, -size * 0.25);
            group.add(rightEye);

            // Tail
            const tailGeom = new THREE.ConeGeometry(size * 0.4, size * 1.2, 4);
            tailGeom.rotateZ(Math.PI / 2);
            const tailMat = new THREE.MeshStandardMaterial({
                color: colorScheme.body,
                roughness: 0.3,
                metalness: 0.3,
                side: THREE.DoubleSide
            });
            const tail = new THREE.Mesh(tailGeom, tailMat);
            tail.position.x = -size * 1.8;
            tail.scale.set(1, 0.1, 1);
            group.add(tail);

            // Dorsal fin
            const dorsalGeom = new THREE.ConeGeometry(size * 0.3, size * 0.6, 4);
            dorsalGeom.rotateX(-Math.PI / 6);
            const dorsal = new THREE.Mesh(dorsalGeom, tailMat);
            dorsal.position.set(0, size * 0.4, 0);
            group.add(dorsal);

            // Pectoral fins
            const finGeom = new THREE.ConeGeometry(size * 0.15, size * 0.4, 4);
            
            const leftFin = new THREE.Mesh(finGeom, tailMat);
            leftFin.position.set(size * 0.8, -size * 0.1, size * 0.4);
            leftFin.rotation.x = Math.PI / 3;
            group.add(leftFin);

            const rightFin = new THREE.Mesh(finGeom, tailMat);
            rightFin.position.set(size * 0.8, -size * 0.1, -size * 0.4);
            rightFin.rotation.x = -Math.PI / 3;
            group.add(rightFin);

            // Position fish in pond
            const angle = Math.random() * Math.PI * 2;
            const radius = 2 + Math.random() * 6;
            group.position.set(
                Math.cos(angle) * radius,
                -0.4 - Math.random() * 0.8,
                Math.sin(angle) * radius
            );
            group.rotation.y = angle + Math.PI / 2;

            return {
                group,
                angle,
                radius,
                speed: 0.1 + Math.random() * CONFIG.fish.swimSpeed,
                verticalOffset: Math.random() * Math.PI * 2,
                wobble: Math.random() * 0.5 + 0.5,
                size,
                targetAngle: angle
            };
        }

        // ============================================
        // LILY PADS
        // ============================================
        function createLilyPads() {
            const positions = [
                { x: -3, z: -2, scale: 1 },
                { x: -4.5, z: -1, scale: 0.8 },
                { x: -2, z: -3.5, scale: 0.7 },
                { x: 2, z: 4, scale: 1.1 },
                { x: 3.5, z: 3, scale: 0.75 },
                { x: -5, z: 4, scale: 0.9 },
                { x: 1, z: -5, scale: 0.85 },
                { x: 5, z: -2, scale: 0.95 }
            ];

            positions.forEach((pos, i) => {
                const lilypad = createLilyPad(pos.scale, i % 3 === 0);
                lilypad.position.set(pos.x, -0.05, pos.z);
                lilypad.rotation.y = Math.random() * Math.PI * 2;
                scene.add(lilypad);
            });
        }

        function createLilyPad(scale, hasFlower) {
            const group = new THREE.Group();

            // Pad shape with notch
            const shape = new THREE.Shape();
            const radius = 0.5 * scale;
            
            for (let i = 0; i <= 32; i++) {
                const angle = (i / 32) * Math.PI * 2;
                // Create notch
                let r = radius;
                if (angle > Math.PI * 0.9 && angle < Math.PI * 1.1) {
                    r = radius * 0.3;
                }
                const x = Math.cos(angle) * r;
                const y = Math.sin(angle) * r;
                
                if (i === 0) shape.moveTo(x, y);
                else shape.lineTo(x, y);
            }

            const padGeom = new THREE.ShapeGeometry(shape);
            const padMat = new THREE.MeshStandardMaterial({
                color: 0x2d5a2d,
                roughness: 0.7,
                metalness: 0.1,
                side: THREE.DoubleSide
            });

            const pad = new THREE.Mesh(padGeom, padMat);
            pad.rotation.x = -Math.PI / 2;
            pad.receiveShadow = true;
            group.add(pad);

            // Lotus flower
            if (hasFlower) {
                const flower = createLotusFlower(scale * 0.4);
                flower.position.set(0, 0.1, 0);
                group.add(flower);
            }

            return group;
        }

        function createLotusFlower(scale) {
            const group = new THREE.Group();

            // Inner petals
            for (let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const petal = createPetal(scale * 0.7, 0xffb6c1);
                petal.position.set(
                    Math.cos(angle) * scale * 0.15,
                    scale * 0.1,
                    Math.sin(angle) * scale * 0.15
                );
                petal.rotation.y = angle;
                petal.rotation.x = -Math.PI / 4;
                group.add(petal);
            }

            // Outer petals
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2 + Math.PI / 12;
                const petal = createPetal(scale, 0xffc0cb);
                petal.position.set(
                    Math.cos(angle) * scale * 0.3,
                    0,
                    Math.sin(angle) * scale * 0.3
                );
                petal.rotation.y = angle;
                petal.rotation.x = -Math.PI / 6;
                group.add(petal);
            }

            // Center
            const centerGeom = new THREE.SphereGeometry(scale * 0.2, 8, 8);
            const centerMat = new THREE.MeshStandardMaterial({
                color: 0xffd700,
                roughness: 0.4
            });
            const center = new THREE.Mesh(centerGeom, centerMat);
            center.position.y = scale * 0.15;
            center.scale.y = 0.5;
            group.add(center);

            return group;
        }

        function createPetal(scale, color) {
            const shape = new THREE.Shape();
            shape.moveTo(0, 0);
            shape.quadraticCurveTo(scale * 0.3, scale * 0.5, 0, scale);
            shape.quadraticCurveTo(-scale * 0.3, scale * 0.5, 0, 0);

            const geom = new THREE.ShapeGeometry(shape);
            const mat = new THREE.MeshStandardMaterial({
                color,
                roughness: 0.5,
                side: THREE.DoubleSide
            });

            const petal = new THREE.Mesh(geom, mat);
            petal.castShadow = true;
            return petal;
        }

        // ============================================
        // JAPANESE LANTERN
        // ============================================
        function createLantern() {
            const group = new THREE.Group();
            const stoneMat = new THREE.MeshStandardMaterial({
                color: 0x5a5a5a,
                roughness: 0.9
            });

            // Base
            const baseGeom = new THREE.CylinderGeometry(0.5, 0.6, 0.2, 6);
            const base = new THREE.Mesh(baseGeom, stoneMat);
            base.castShadow = true;
            group.add(base);

            // Pillar
            const pillarGeom = new THREE.CylinderGeometry(0.15, 0.2, 1.5, 6);
            const pillar = new THREE.Mesh(pillarGeom, stoneMat);
            pillar.position.y = 0.85;
            pillar.castShadow = true;
            group.add(pillar);

            // Light chamber
            const chamberGeom = new THREE.BoxGeometry(0.6, 0.5, 0.6);
            const chamber = new THREE.Mesh(chamberGeom, stoneMat);
            chamber.position.y = 1.85;
            chamber.castShadow = true;
            group.add(chamber);

            // Light inside
            const lightGeom = new THREE.SphereGeometry(0.15, 8, 8);
            const lightMat = new THREE.MeshBasicMaterial({
                color: 0xffdd88,
                transparent: true,
                opacity: 0.8
            });
            const light = new THREE.Mesh(lightGeom, lightMat);
            light.position.y = 1.85;
            group.add(light);

            // Point light
            const pointLight = new THREE.PointLight(0xffdd88, 0.5, 5);
            pointLight.position.y = 1.85;
            group.add(pointLight);

            // Roof
            const roofGeom = new THREE.ConeGeometry(0.6, 0.4, 4);
            const roof = new THREE.Mesh(roofGeom, stoneMat);
            roof.position.y = 2.3;
            roof.rotation.y = Math.PI / 4;
            roof.castShadow = true;
            group.add(roof);

            // Top ornament
            const topGeom = new THREE.SphereGeometry(0.1, 8, 8);
            const top = new THREE.Mesh(topGeom, stoneMat);
            top.position.y = 2.6;
            group.add(top);

            group.position.set(-6, -0.4, -6);
            scene.add(group);
        }

        // ============================================
        // ANIMATION
        // ============================================
        function animate() {
            requestAnimationFrame(animate);

            const time = clock.getElapsedTime();

            // Update water
            if (waterMaterial) {
                waterMaterial.uniforms.uTime.value = time * CONFIG.water.waveSpeed;
            }

            // Animate fish
            fishes.forEach((fish, i) => {
                // Swimming motion
                fish.angle += fish.speed * 0.01;
                
                // Occasional direction changes
                if (Math.random() < 0.002) {
                    fish.radius = Math.max(2, Math.min(8, fish.radius + (Math.random() - 0.5) * 2));
                }

                // Position
                const x = Math.cos(fish.angle) * fish.radius;
                const z = Math.sin(fish.angle) * fish.radius;
                
                fish.group.position.x = x;
                fish.group.position.z = z;
                
                // Vertical bobbing
                fish.group.position.y = -0.5 + Math.sin(time * 0.5 + fish.verticalOffset) * 0.15;

                // Rotation to follow path
                fish.group.rotation.y = fish.angle + Math.PI / 2;

                // Tail waggle
                const tailWaggle = Math.sin(time * 4 + i) * 0.2;
                if (fish.group.children[5]) { // tail
                    fish.group.children[5].rotation.y = tailWaggle;
                }

                // Body undulation
                fish.group.rotation.z = Math.sin(time * 3 + i) * 0.05;
            });

            // Update controls
            controls.update();

            // Render
            renderer.render(scene, camera);
        }

        // ============================================
        // EVENT HANDLERS
        // ============================================
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            mousePos.x = event.clientX / window.innerWidth;
            mousePos.y = event.clientY / window.innerHeight;

            if (waterMaterial) {
                waterMaterial.uniforms.uMouse.value.set(mousePos.x, mousePos.y);
            }
        }

        function onDoubleClick(event) {
            // Smooth camera reset on double click
            controls.target.set(0, -0.5, 0);
        }

        function updateTimeDisplay() {
            const now = new Date();
            const hours = now.getHours().toString().padStart(2, '0');
            const minutes = now.getMinutes().toString().padStart(2, '0');
            document.getElementById('time-display').textContent = `${hours}:${minutes}`;
        }

        // ============================================
        // START
        // ============================================
        init();
    </script>
</body>
</html>
